# 애그리거트(Aggregate)

---
- 도메인주도개발(DDD)에 소개된 **도메인 모델 구성 요소/패턴**의 하나이다
- **데이터 변경의 목적**을 위해 **하나의 단위로 취급**되는 **연관되는 객체들의 클러스터**이다
- 루트(root)와 경계(boundary)를 가진다
- 경계 내부에는 엔티티와 값 객체가 하나 또는 여러 개가 존재할 수 있다
- 애그리거트 루트는 내부에 포함된 단일 엔티티이다

# 애그리거트의 특징

---
- 데이터 변경 시 하나의 단위로 취급: 데이터 변경의 일관성을 유지한다
- 루트를 통한 접근 제어: 외부 객체는 루트엔티티에만 참조를 가질 수 있다
- 데이터 일관성 유지
  - 경계 내의 어떤 변경 사항이 있을 때 전체 애그리거트의 모든 **불변식이 충족**되어야 한다
    - `invariant`(불변식) : 도메인 모델이 항상 만족(참)해야 하는 조건
    - ex) MemberDetail이 있을 때 Member는 Active여야 한다
  - 애그리거트를 넘어서는 불변식은 **이벤트나 배치** 등을 통해 특정시간 내에 해결할 수 있다
- 검색 및 접근 방식: **Repository**를 통해서 **애그리거트 루트**만 직접 얻을 수 있다
  - 내부 엔티티는 루트로부터 연관관계를 통해서 접근한다
- 생명주기 관리 캡슐화: Factory와 Repository를 이용해서 객체들을 생명주기에 걸쳐 체계적이고 의미있는 단위로 조작

# 애그리거트의 목표

---
- 일관성 유지: 객체 그룹에 적용되는 **불변식을 유지**하는 수단
- 이해 용이성: 객체의 시작과 끝을 명확히 해서 **모델을 더 쉽게 이해**하게 한다
- 트랜잭션 및 동시성 관리: **트랜잭션 범위**와 **데이터 일관성 유지** 방법 제공
- 모델 단순환: 연관 관계 탐색을 제한하고 **루트를 통해서만 접근**하도록 해준다
- Factory와 Repository가 복잡한 생명주기 전환을 캡슐화하는 단위가 되도록 한다

# 애그리거트 적용 방법

---
- JPA의 **cascading**을 적절하게 활용한다
  - ex) Member -> cascade -> MemberDetail
- Repository는 **애그리거트 단위**로 만든다
  - 스프링 데이터 JPA의 핵심 원칙
  - Repository<T, ID>: T = Aggregate Root
  - 리포지토리 리턴 타입은 애그리거트 루트
- 가능하다면 하나의 트랜잭션에 하나의 애그리거트만 변경한다
- 다른 애그리거트의 참조는 애그리거트 루트에 대해서만 한다
  - 연관관계 애그리거트 루트의 레퍼런스 대신 루트의 ID 값만 저장하기도 한다

# 애그리거트 설계와 적용의 어려움

---
- 적절한 애그리거트 경계를 선택하는 것은 꽤 어려운 결정이다
- 개발하면서 애그리거트의 범위가 달라지기도 한다
  - 대체로 작은 애그리거트가 될 가능성이 높다
- 성능에 부담을 주게 된다 (**lazy loading**의 도움이 필요)
- 내부 엔티티로의 직접 접근이나 여러 애그리거트를 한번에 조회하는 기능이 필요한 경우가 있다
- **도메인 이벤트**와 **최종적 일관성**(eventual consisntency)의 사용이 요구된다
- 완벽한 애그리거트가 아니어도 괜찮다
  - 누가 시비 걸면 우리는 DDD 하지 않는다고 하면 된다^^

# 헥사고날 아키텍처와 애그리거트

---
- **애그리거트 단위로 애플리케이션(헥사곤)을 구성**하는 방법이 유용하다
- 다른 애그리거트로의 접근은 애플리케이션 **포트를 통해서 ID를 전달**하는 방식으로
  - 애플리케이션 내부 리포지토리에서 루트 엔티티를 조회하는 방식으로 이루어지게 강제할 수 있다
  - 내가 ID를 가지고 있는데 또 이거로 엔티티를 조회하는 이 방식이 괜찮냐?
  - 어! JPA가 있기 때문에 괜찮아!
- 도메인 이벤트와 리스너를 이용해서 애그리거트 사이의 작업을 연결할 수도 있다
    
    