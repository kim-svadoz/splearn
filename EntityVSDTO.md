# 애플리케이션 포트의 리턴 타입은? Entity VS DTO

---
애플리케이션에서 도메인 로직을 적용하고 엔티티의 정보를 돌려줄 때 어떤 타입을 사용하는가?
  - 엔티티(애그리거트 루트)
  - DTO

# 1. 애플리케이션(서비스) 계층의 리턴 타입은 DTO여야 한다? (주장)

---
- 계층형 아키텍처에서 각 계층은 자기 바로 다음(하위) 게층에만 의존해야 한다는 제약이 있다
- 도메인 계층에 존재하는 엔티티는 애플리케이션 계층에서만 사용하고, 그 밖으로 전달할 때는 필요한 값만 뽑아서 DTO로 만들어서 전달해서 아키텍처 제약을 따른다.
- 도메인 로직을 가지고 있는 엔티티가 프레젠테이션 로직을 가진 어댑터(컨트롤러)로 유출되면 도메인로직을 담은 메소드를 실행할 수 있는 문제가 있다
  - OSIV와 결합하면 컨트롤러에서 DB변경이 일어날 수도 있다.
  - OSIV: Open Session In View(Persistent context in controller)
    - 트랜잭션이 끝난 후에도 영속성 컨텍스트가 살아있어서 지연로딩이 가능하게 하는 패턴
- 헥사고날 아키텍처(또는 클린아키텍처, 계층형 아키텍처)에서 도메인/애플리케이션 계층 밖으로 보낼 때는 반드시 DTO에 담아서 전달한다

# 2. 애플리케이션(서비스) 계층의 리턴 타입은 가능하다면 엔티티로 한다. (반박)

---
- 현대적인 엔터프라이즈 애플리케이션은 이 제약을 완화시킨 **완화된 계층형 아키텍처**를 주로 사용한다
- 계층형 아키텍처의 목적은 **시스템의 관심사를 분리**하는 것이다
- 이를 통해서 전체적인 결합도를 낮추고 인지 과부하를 방지해서 재사용성과 유지보수성을 높인다
- 엔티티가 가진 정보 조회를 넘어서 엔티티 로직을 사용하므로 도메인 로직이 유출되는 문제는 엔티티에서만 발생하는 것이 아니다
  - DTO를 가지고도 얼마든지 컨트롤러에서 "도메인 로직"을 구현할 수 있다
- 어차피 세컨더리 어댑터에서도(repository 구현 어댑터, 메일 발송 어댑터 등)에도 엔티티가 전달되거나 생성되어 리턴된다
- 근본적으로 repository 어댑터에서 도메인 엔티티를 제거할 방법은 없다. 여기서 도메인 로직을 실행할 수 있는 것은 문제가 아닌가?
- OSIV가 적용됐다고 하더라도 애플리케이션에서 리턴할 때 트랜잭션이 종료된다
- 따라서 이후의 엔티티 변경사항은 DB에 커밋되지 않는다
- DTO를 쓰는것을 반대한다! 왜냐?
- DTO를 리턴하는 방식의 가장 큰 문제는 프레젠테이션 로직이 애플리케이션 레이어로 침투하는 것이다
- Web API에서 요구하는 정보가 무엇인지, 즉 뷰(view)로직에 따라 엔티티에서 복제되는 DTO의 구성이 달라진다
  - DTO와 이를 매핑하는 코드는 모두 애플리케이션 계층이다
- 따라서 DTO를 통해 애플리케이션 계층이 어댑터 계층의 로직에 의존한다
- 상위(외부)계층의 로직을 하위(내부)계층이 의존하는 것은 계층형과 헥사고날 아키텍처 모두의 근간을 깨는 행위이다
- **엔티티(애그리거트 루트)를 돌려주고** 어떤 정보를 사용자에게 전달할지 선택하는 **뷰 로직은 프레젠테이션 관심사를 가진 웹 API 어댑터가 담당**한다!
- 엔티티 단위가 아닌 복잡한 리포트성 조회 결과는 DTO를 리턴한다. 이 자체가 도메인 로직이다

> 개발 가이드와 코드 리뷰를 통해서 내부의 로직이 외부에 새어나가는 코드를 작성하지 않도록 주의한다.
> 
> 정적분석 도구나 아키텍처 테스트의 도움을 받아서 엔티티의 조회 메소드 외의 메소드가 사용되는 것을 체크할 수도 있다.
> 
> OSIV는 프레젠테이션/API 로직이 애플리케이션과 세컨더리 어댑터 계층(리포지토리 구현)까지 결합되는 것을 막아주는 좋은 도구이다.
> 
> 하지만 대용량 트래픽과 높은 성능을 위한 최적화가 요구되는 경우에는 사용하지 않는 것이 좋다.
> DB 커넥션과 JPA 영속 컨텍스트가 유지되는 것이 영향을 줄 수 있기 때문이다.

*애플리케이션 기능 제공 인터페이스의 리턴타입은 엔티티와 애그리거트, 혹은 그 이상의 연관관계로 애플리케이션 로직 수행 결과를 리턴하기 어려운 경우에만 DTO 클래스/레코드를 만들어 사용한다!!*
