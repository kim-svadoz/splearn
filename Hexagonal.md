# 아키텍처

- 시스템의 기본적인 구조를 정의한다
- 시세틈의 중요한 품질 속성에 큰 영향을 미친다
- 설계 결정의 기반이 되는 핵심적인 개념이다
- 기본 구성 요소와 상호 관계, 제약 조건, 원칙 등을 포함한다
---
# 계층형 아키텍처(Layered Architecture)
- 서브 시스템을 **계층(layers)로 구조화** 하는 아키텍처 스타일이다
- 계층을 **사용 관계로 연결**된다
- 사용 관계는 일반적으로 **단방향이어야 한다**는 핵심 제약이 있다
  - 상위 계층이 하위 계층의 서비스를 사용하는 **하향식 흐름**을 가진다.
- 각 계층이 하위 계층의 내부 작동 방식을 알지 못하고 **제한된 인터페이스만 사용**하도록 한다 (계층 격리 Layers of Isolation)
  - 어떤 레이어의 **변경**이 다른 레이어의 컴포넌트에게 가능한 **영향을 주지 않도록** 해야 한다

## 3계층 아키텍처
> UI(`Presentation`) -> Domain(`Business Logic`[Transaction Script]) -> Data(`Infra`)

Domain Model Pattern을 도메인 Layer에 넣을 수 없기 때문에

Application Service와 Domain으로 나누어 도메인 Layer를 구성한다.

Domain을 조금 더 순수하게 남겨두고 외부 시스템과의 연결이 필요하다면, Application에서 Infra를 사용하도록 한다.

---
# 헥사고날 아키텍처
- 2005년 앨리스터 코번(Alistair Cockburn)이 제안한 아키텍처
- 계층형 아키텍처의 단방형 비대칭 구조가 아닌 **대칭형(symmetric)** 아키텍처
- 위 아래, 좌 우가 아닌 애플리케이션의 내부와 위부 세계라는 대칭 구조를 가진다
- 아키텍처의 대칭성을 가진 구조를, 그리기 쉬운 대표적인 도형인 **육각형(hexagonal)**으로 설명
- 육각형, 6개의 면을 가졌다는게 특별한 의미를 가지는 건 아니다.

## 헥사곤의 내부
- 쉽게 변하지 않는, **중요한 도메인 로직**을 담은 코어 애플리케이션
  - 도메인 로직을 가진 **트랜잭션 스크립트**
  - 애플리케이션 서비스와 **도메인 모델 패턴**을 따라서 만든 도메인
## 헥사곤의 외부
- 헥사곤과 상호작용(interaction)하는 모든 것 - 액터(Actor)
- 사용자, 브라우저, CLI명령, 기계, 다른 시스템
- 운영 환경, DB, 메시징 시스템, 메일 시스템, 원격 서비스
- 테스트

## 헥사고날 아키텍처의 특징과 혜택
- **테스팅**!! 운영 시스템에 연결되지 않고 애플리케이션 테스트
- 애플리케이션과 상호작용하는 액터가 바뀌더라도 다시 빌드하지 않고 테스트
- UI 디테일이나 기술 정보가 **도메인 로직 안으로 노출되지 않도록 보호**한다. 반대도 마찬가지
- 컴포넌트를 각각 개발하고 연결하는 방식으로 **큰 시스템을 분리**할 수 있다
- 시간이 지나면서 **외부 연결을 다른 것으로 변경**할 수 있다
- 기술 요소를 제거했기 때문에 **도메인 설계에 집중**할 수 있다

## 헥사곤을 부르는 여러가지 이름
- 헥사곤
- **애플리케이션**
- 앱(App)
- 코어 시스템
- SuD(System under Development)
- SuT(System under Test)

## 액터와 애플리케이션의 상호작용은 어떻게?

### - 포트(port)
- 애플리케이션이 외부 세계와 **의도(intention)을 가지고 상호작용 하는** 아이디어를 캡처한 것
- 단순히 데이터를 주고받는 것이 아니라, **명확한 목적과 방향**을 가지고 **외부와 연결**된다
- 애플리케이션이 정의한 **인터페이스로** 만들어진다

### - 인터페이스
- Lollipop: Provided Interface
- Socket: Required Interface

### 기능제공 인터페이스(Provided Interface)
- 애플리케이션이 가지고 있는 기능을 외부 액터가 사용할 수 있게 제공하는 인터페이스
Primary Actor는 Provided Interface를 사용한다.

### 기능요구 인터페이스(Required Interface)
- 애플리케이션이 기능을 가지고 있지는 않지만 이런 기능이 필요하니 이런 방식으로 연결을 해줘 하고 요구하는 인터페이스
Actor일수도 있고, Adapter일수도 있다.(Secondary Actor)

### - 어댑터(Adapter)
- 애플리케이션의 포트를 액터가 직접 연결할 수 없다면 **인터페이스의 변환을 위한 어댑터**를 도입
- 브라우저를 통해서 애플리케이션의 회원 가입 포트의 기능 제공 인터페이스를 사용하려면?
  - 회원 가입 **기능제공 인터페이스**를 사용하는 **웹 컨트롤러 어댑터**를 만든다.
- 애플리케이션이 가진 회원 정보 저장 포트의 기능 요구 인터페이스로 DB와 직접 연결할 수 없다면?
  - **기능요구 인터페이스**를 구현한 **리포지토리 어댑터**를 만든다

#### 포트와 어댑터 아키텍처
- 헥사고날 아키텍처의 특징을 담은 새로운 이름
- 하지만 여전히 헥사고날 아키텍처라는 이름이 더 많이 사용된다

### 헥사고날 아키텍처의 비대칭성
- 애플리케이션이 제공하는 기능을 사용하는 액터와 이를 위한 어댑터
  - primary actor, primary adapter
  - driving actor, driving adapter
- 애플리케이션이 동작하는데 필요한 기능을 제공하는 액터와 이를 위한 어댑터
  - secondary actor, secondary adapter
  - driven actor, driven adapter
---

## 오해1: 애플리케이션 내부에 도메인 계층을 만들어야 한다.
- 헥사고날 아키텍처는 애플리케이션 **내부 구현에 대한 원칙이나 요구사항이 없다**
  - 스파게티 코드로 만들어도 된다
  - tx script, 도메인 모델 패턴과 애플리케이션 서비스 등도 가능하다
  - 도메인 계층을 포함하는 아키텍처는 클린 아키텍처이다
- 헥사고날 아키텍처는 클린 아키텍처, 어니언(onion) 아키텍처가 아니다

## 오해2: 헥사고날 아키텍처 패키지 구조를 따라야 한다
- 헥사고날 아키텍처가 **요구하는 패키지 구조는 없다**
- **애플리케이션과 어댑터 패키지를 분리**하는 것은 바람직하다
- **포트를 구분된 패키지에 두는 것을 권장한다**

## 오해3: 포트는 UseCase 라는 접미사를 사용한다
- **포트의 의도**를 담은 이름을 사용하면 된다
- `For + ~ing` 스타일의 권장 네이밍이 있지만 이를 따를 필요는 없다

## 오해4: 애플리케이션에는 도메일 모데만 넣고 JPA 엔티티 등은 어댑터에 둬야 한다
- 애플리케이션 코드와 포트 인터페이스가 **외부 기술에 의존하지 않으면** 된다

## 사실: 헥사고날 아키텍처가 요구하는 것
1. 애플리케이션은 모든 외부와의 상호작용을 위해서 **provided interface와 required interface**를 정의한다
   - 의존관계 역전..(DIP)
2. 애플리케이션과 상호작용 하는 **액터는 런타임에 구성**되어야 한다
3. 애플리케이션은 **액터에 대한 코드 의존성**을 가지면 안된다
4. 액터는 **정의된 포트를 통해서만** 연결해야 한다
5. 포트의 인터페이스에는 **기술 의존성을 가지지 않는다**

---

# Splearn 개발에 적용할 아키텍처 패턴
- 헥사고날 아키텍처
- 도메인 모델 패턴 (PATTERNS OF APPLICATION ARCHITECTURE)

## 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조
- 도메인 계층
- 애플리케이션 계층
- 어댑터 계층
- 외부에서 내부로 향하는 일종의 **계층구조**
- 코드의 의존 방향은 내부로만 향한다
  - [어댑터] -> [애플리케이션] -> [도메인]
- 단, 사용의 흐름은 비대칭적이다

---
# 도메인 주도 개발(DDD)의 아키텍처는?
- 4개의 계층형 아키텍처: Eric Evans
- 헥사고날 아키텍처: Vaugn Vernon

DDD의 창시자는
> 헥사고날 아키텍처를 들었습니다. DDD의 아키텍처는 이제 헥사고날 아키텍처라고 생각하면 됩니다.

라고 했다고 함.
