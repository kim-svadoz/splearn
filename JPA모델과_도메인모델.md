# JPA 모델과 도메인 모델은 다른 것인가?

---
- **도메인모델**은 DB와 매핑되는 **데이터 모델**과 다르며 이를 분리해야 한다
  - 어댑터 계층에 JPA 엔티티 등의 모델을 따로 만들고
  - Repository를 구현한 어댑터를 이용해서 도메인 오브젝트와 JPA 오브젝트를 매핑해준다
  - Member 외에 MemberEntity 클래스를 만들어 JPA 관련 설정은 모두 이곳으로 옮긴다.
  - MemberRepository를 구현한 MemberRepositoryJpaAdapter에서 이 두가지 오브젝트를 서로 매핑해주는 코드를 작성한다
  
## 이런 접근 방법을 선호하는 이유

---
- 데이터 모델과 도메인 모델이 너무 다른 경우 [ 추천 1 ]
  - 레거시 DB에 도메인 모델 설계를 적용하는 경우
- 복잡한 도메인 모델이 데이터 모델과 간단히 매핑되지 않는 경우 [ 추천 2 ]
  - JPA 모델과는 다른 도메인 모델이 존재한다면
- 데이터 저장 기술이 바뀌는 경우 ( -> 그렇게 설득력이 있지 않음 )
  - Spring Data 프로젝트의 존재 이유임. 저장 기술이 바뀌어도 Repository 인터페이스는 바뀌지 않음
- 코드에 등장하는 JPA 어노테이션은 **기술 의존적** 이니까! [ 동의 X ]
  - (도메인 모델을 먼저 만들고 JPA Entity여도 되겠다고 싶어서 변환한 것임, JPA는 표준기술임)
  - (주석은 말 그대로 주석. 실행에 영향을 주지 않음)
  - 어노테이션이 코드의 실행에 영향을 줄까?
  - 도메인 코드에 관심사가 다른 JPA 매핑 어노테이션, DB정보가 들어가니까 보기가 싫은 것임

# JPA 기술의 정체성

---
- ORM : 패러다임이 다른 **관계형 DB와 객체지향 모델의 불일치를 해결**하는 기술
  - SQL 매핑과는 다른 의미임
- JPA의 기술적 목표는 자바 애플리케이션 개발자가 관계형 데이터베이스를 관리하기 위해 **자바 도메인 모델을 활용**할 수 있는 객체/관계 매핑 기능을 제공하는 것
- JPA의 엔티티는 **경량 영속 도메인 오브젝트** (lightweight persistent domain object)이다
  - 단순히 sql mapper가 아니다.

# 도메인 모델 패턴

---
- 단순 도메일 모델은 테이블과 클래스가 1:1로 매핑된다
- 복잡한 도메인 모델을 DB 매핑이 어렵다는 문제가 있다
  - 이걸 해결해주는 것이 JPA(ORM) 기술
- JPA(ORM)이 매핑을 통해서 해결하려는 **패러다임 불일치 문제**를 해결한다
  1. 세분성(Granularity) 불일치 - DB와 Class가 1:1이 아님.
  2. 상속(Subtype) 불일치
  3. 정체성(Identity) 불일치 - PK에 정체성이 들어가있음. hashCode, equals 재정의 필요
  4. 연관(Association) 불일치 - PK, FK로 해결
  5. 데이터 탐색(Navigation) 불일치 - Lazy, Eager

# 스프링 데이터 프로젝트

---
- 다양한 데이터 저장소(RDB, NOSQL DB, 클라우드 기반 데이터 서비스 등)에 대한 데이터 접근을 단순하고 일관된 프로그래밍 모델로 제공
  - 일관된 프로그래밍 모델: 저장소 종류와 관계없이 동일한 방식으로 데이터에 접근하도록 한다
  - 보일러 플레이트 코드 감소
  - 데이터 저장소의 특성 유지
  - 확장성과 유연성
- `Repository<T, ID>`
  - `T:` **도메인 타입 = 엔티티 = 애그리거트 루트**

# 도메인 모델과 JPA 모델을 반드시 분리해야 한다는 주장에 대한 반박

---
- 그럴 필요도 있음. 하지만
- 대부분 데이터 모델과 도메인 모델이 다르지 않음
- 복잡한 도메인 모델의 매핑은 **JPA가 충분히 지원**, 표준에 있지 않아도 **hibernate**가 지원하는 다양한 매핑 기술방식이 존재함.
- 모델 변환 로직과 유사한 두 가지 클래스로 인한 **불필요한 복잡성이 증가**함
- JPA는 근본적으로 도메인 오브젝트의 매핑을 위해서 설계된 기술이고, 그 철학에 맞게 하자!
- JPA는 도메인 계층을 침범하지 않음
- 복잡한 쿼리 로직은 **Custom Repoistory**와 **Adapter**를 구현해서 개발 가능
- 도메인 계층과 데이터 계층의 결합은 불가피하다
  - 이 둘이 완전히 독립적인 경우는 매우 드물다
- JPA는 충분히 유연하고 막강하고, Spring Data JPA는 놀라운 수준의 도메인 중심 개발 지원

> 성급한 분리는 오히려 복잡성만 초래할 뿐이고
> JPA는 도메인 모델 중심의 개발을 충분히 잘 지원한다

*하지만 도메일 모델에 등장하는 도메인 관심사가 아닌 각종 JPA 매핑 어노테이션은 어떻게 제거할 방법이 없을까...?*

** XML은 Annotation 설정을 override 한다 ! **
- 장점이 있다면, 스키마가 있기 때문에 문법에 맞게 작성하지 않으면 에러를 내줌.
- AI가 이걸 너무 잘해줌 (ex. copilot... orm.xml에 들어갈 <entity>만들어줘! )
